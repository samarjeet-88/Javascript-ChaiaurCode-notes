//THERE ARE TWO TYPES OF DATATYPE=>PRIMITIVE(CALL BY VALUE) AND NON-PRIMITIVE(CALL BY REFERENCE)
//DIFFERNETIATED ON THE BASIS OF HOW THE DATATYPE IS STORED AND HOW THEY ACCESSED IN THE MEMORY

//CALL BY VALUE MEANS WHEN WE ARE TRYING TO ACCESS OR COPY THE PRIMITIVE DATATYPE THE ORIGINAL VALUE IS COPIED AND THEN STORED ON A NEW ADDRESS
// IF A="5" NOW IF WE COPY A INTO B (B=A)THE ADDRESS OF B POINTS TO NEW LOCATION IN MEMORY CONTAINING THE SAME VALUE AS A
//PRIMITIVE(CALL BY VALUE)=>String,Number,Boolean,null,undefined,Symbol,BigInt(bigger value of int)

//IN CALL BY REFERENCE NO NEW MEMOERY LOCATION IS CREATED AND NO NEW OBJECT IS CREATED
//WE HAVE AN OBJECT STORED IN A.NOW WE COPY A TO B(B=A).INSTEAD OF POINTING TO A NEW LOCATION IN MEMORY IT POINTS TO THE SAME LOCATION AS THE B
//NON-PRIMITIVE(CALL BY REFERENCE)=>Array,Objects,Functions

// const id=Symbol('123')
// const id2=Symbol('123')
// console.log(id===id2)//FALSE

// const bigNumber=344567890123456789012345678901234567890n
// ADD n AT THE END TO CONVERT IT TO BIGINT
// console.log(typeof bigNumber);


const heros=["shaktiman","naagraj","doga"];
// console.log(typeof heros)=>//OBJECT

//OBJECT=>KEY VALUE PAIR
let myObj={
    name:"hitesh",
    age:22
}
// console.log(typeof myObj)=>OBJECT


const myFunc=function(){
    console.log("hello world");
}
// console.log(typeof myFunc)=>FUNCTION(BUT CALLED AS OBJECT FUNCTION)


//++++++++++++++++++++++++MEMORY++++++++++++++++
//TWO TYPES OF MEMORY=>STACK,HEAP
//IN PRIMITIVE TYPE STACK MEMORY IS USED
//IN NON-PRIMITIVE TYPE HEAP MEMORY IS USED
//IN STACK THE COPY VARIABLE IS USED.BUT IN HEAP THE ORIGINAL REFERNCE IS OBTAINED





